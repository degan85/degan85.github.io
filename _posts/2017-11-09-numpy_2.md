---
layout: post
title: "numpy 기초 2"
author: Degan
categories: machine_learning
tags:	jupyter python notebook
original_extension: ipynb
comments: true
---

# 4.2 유니버설 함수


In[
1
]
```python
import numpy as np
```


In[
2
]
```python
arr = np.arange(10)
```


In[
3
]
```python
np.sqrt(arr)
```




    array([ 0.        ,  1.        ,  1.41421356,  1.73205081,  2.        ,
            2.23606798,  2.44948974,  2.64575131,  2.82842712,  3.        ])




In[
4
]
```python
np.exp(arr)
```




    array([  1.00000000e+00,   2.71828183e+00,   7.38905610e+00,
             2.00855369e+01,   5.45981500e+01,   1.48413159e+02,
             4.03428793e+02,   1.09663316e+03,   2.98095799e+03,
             8.10308393e+03])




In[
5
]
```python
x = np.random.randn(8)
```


In[
6
]
```python
y = np.random.randn(8)
```


In[
7
]
```python
x
```




    array([ 0.43751709,  0.09366465,  1.26058603, -0.46586497, -0.49826517,
            1.72837403, -0.61995532,  0.63160911])




In[
8
]
```python
y
```




    array([ 0.4211775 , -0.35338936, -0.78295176,  1.08700811,  0.51654954,
           -0.73476457, -1.19221714, -0.14248035])




In[
9
]
```python
np.maximum(x, y)
```




    array([ 0.43751709,  0.09366465,  1.26058603,  1.08700811,  0.51654954,
            1.72837403, -0.61995532,  0.63160911])




In[
10
]
```python
arr = np.random.randn(7) * 5
```


In[
11
]
```python
np.modf(arr)
```




    (array([-0.16735724, -0.75503588, -0.16735153,  0.78005253, -0.03584805,
             0.40987398,  0.90534373]), array([-0., -1., -0.,  9., -8.,  7.,  2.]))



# 4.3 배열을 사용한 데이터 처리


In[
12
]
```python
points = np.arange(-5, 5, 0.01)
```


In[
13
]
```python
xs, ys = np.meshgrid(points, points)
```


In[
14
]
```python
ys
```




    array([[-5.  , -5.  , -5.  , ..., -5.  , -5.  , -5.  ],
           [-4.99, -4.99, -4.99, ..., -4.99, -4.99, -4.99],
           [-4.98, -4.98, -4.98, ..., -4.98, -4.98, -4.98],
           ..., 
           [ 4.97,  4.97,  4.97, ...,  4.97,  4.97,  4.97],
           [ 4.98,  4.98,  4.98, ...,  4.98,  4.98,  4.98],
           [ 4.99,  4.99,  4.99, ...,  4.99,  4.99,  4.99]])




In[
15
]
```python
import matplotlib.pyplot as plt
```


In[
16
]
```python
z = np.sqrt(xs**2 + ys**2)
```


In[
17
]
```python
z
```




    array([[ 7.07106781,  7.06400028,  7.05693985, ...,  7.04988652,
             7.05693985,  7.06400028],
           [ 7.06400028,  7.05692568,  7.04985815, ...,  7.04279774,
             7.04985815,  7.05692568],
           [ 7.05693985,  7.04985815,  7.04278354, ...,  7.03571603,
             7.04278354,  7.04985815],
           ..., 
           [ 7.04988652,  7.04279774,  7.03571603, ...,  7.0286414 ,
             7.03571603,  7.04279774],
           [ 7.05693985,  7.04985815,  7.04278354, ...,  7.03571603,
             7.04278354,  7.04985815],
           [ 7.06400028,  7.05692568,  7.04985815, ...,  7.04279774,
             7.04985815,  7.05692568]])




In[
18
]
```python
plt.imshow(z, cmap=plt.cm.gray); plt.title("Image plot of $\sqrt{x^2 + y^2}$ for a grid of values");plt.colorbar()
```




    <matplotlib.colorbar.Colorbar at 0x9e78fb0>



## 4.3.1 배열연산으로 조건절 표현하기


In[
19
]
```python
xarr = np.array([1.1, 1.2, 1.3, 1.4, 1.5])
```


In[
20
]
```python
yarr = np.array([2.1, 2.2, 2.3, 2.4, 2.5])
```


In[
21
]
```python
cond = np.array([True, False, True, True, False])
```


In[
22
]
```python
result = [(x if c else y) for x, y, c in zip(xarr, yarr, cond)]
```


In[
23
]
```python
result
```




    [1.1000000000000001, 2.2000000000000002, 1.3, 1.3999999999999999, 2.5]




In[
24
]
```python
result = np.where(cond, xarr, yarr)
```


In[
25
]
```python
result
```




    array([ 1.1,  2.2,  1.3,  1.4,  2.5])




In[
26
]
```python
arr = np.random.randn(4,4)
```


In[
27
]
```python
arr
```




    array([[-0.72542145,  0.78010823,  0.28390986, -1.02398709],
           [-0.26901489, -0.70207514,  1.84935539, -0.39047202],
           [ 1.0672603 , -0.38595696, -0.6560585 ,  0.38493414],
           [ 0.70219244, -0.45966864, -1.92605143, -0.31901316]])




In[
28
]
```python
np.where(arr > 0, 2, -2)
```




    array([[-2,  2,  2, -2],
           [-2, -2,  2, -2],
           [ 2, -2, -2,  2],
           [ 2, -2, -2, -2]])




In[
29
]
```python
np.where(arr > 0, 2, arr)
```




    array([[-0.72542145,  2.        ,  2.        , -1.02398709],
           [-0.26901489, -0.70207514,  2.        , -0.39047202],
           [ 2.        , -0.38595696, -0.6560585 ,  2.        ],
           [ 2.        , -0.45966864, -1.92605143, -0.31901316]])



## 4.3.2 수학 메서드와 통계 메서드


In[
30
]
```python
arr = np.random.randn(5,4)
```


In[
31
]
```python
arr.mean()
```




    0.020637525385935551




In[
32
]
```python
np.mean(arr)
```




    0.020637525385935551




In[
33
]
```python
arr.sum()
```




    0.41275050771871102




In[
34
]
```python
arr.mean(axis=1)
```




    array([ 0.39692638, -0.5277369 ,  0.31019815, -0.09411224,  0.01791224])




In[
35
]
```python
arr
```




    array([[ 0.99419266, -0.13547389, -1.13453381,  1.86352056],
           [-1.34818121,  0.14200817, -0.9567549 ,  0.05198033],
           [ 0.57639047, -0.12946229,  0.17261219,  0.62125223],
           [-0.45318062, -0.3178482 , -0.20604284,  0.60062271],
           [-0.89238878, -0.48628461,  0.79305632,  0.65726602]])




In[
36
]
```python
arr.sum(0)
```




    array([-1.12316749, -0.92706082, -1.33166304,  3.79464186])



## 4.3.3 불리언 배열을 위한 메서드


In[
37
]
```python
arr = np.random.randn(100)
```


In[
38
]
```python
(arr > 0).sum()
```




    50




In[
39
]
```python
bools = np.array([False, False, True, False])
```


In[
40
]
```python
bools.any()
```




    True




In[
41
]
```python
bools.all()
```




    False



## 4.3.4 정렬


In[
42
]
```python
arr = np.random.randn(8)
```


In[
43
]
```python
arr
```




    array([ 0.13949025,  0.50151997, -0.39982838, -0.07423682, -0.89444168,
           -0.21537365,  0.29660191,  0.43217301])




In[
44
]
```python
arr.sort()
```


In[
45
]
```python
arr
```




    array([-0.89444168, -0.39982838, -0.21537365, -0.07423682,  0.13949025,
            0.29660191,  0.43217301,  0.50151997])




In[
46
]
```python
arr = np.random.randn(5,3)
```


In[
47
]
```python
arr
```




    array([[-1.40565512,  0.79886482, -0.49091376],
           [ 1.72292754,  0.38511804, -0.36272227],
           [-0.5088735 ,  0.97096492, -0.78229933],
           [ 0.99965602, -0.44715426,  0.40985475],
           [ 0.39527768, -0.51585355,  0.16370964]])




In[
48
]
```python
arr.sort(1)
```


In[
49
]
```python
arr
```




    array([[-1.40565512, -0.49091376,  0.79886482],
           [-0.36272227,  0.38511804,  1.72292754],
           [-0.78229933, -0.5088735 ,  0.97096492],
           [-0.44715426,  0.40985475,  0.99965602],
           [-0.51585355,  0.16370964,  0.39527768]])




In[
50
]
```python
large_arr = np.random.randn(1000)
```


In[
51
]
```python
large_arr.sort()
```


In[
52
]
```python
large_arr[int(0.05 * len(large_arr))]
```




    -1.6246406378578535



## 4.3.5 집합 함수


In[
53
]
```python
names = np.array(['Bob', 'Joe', 'Will', 'Bob', 'Will', 'Joe', 'Joe'])
```


In[
54
]
```python
np.unique(names)
```




    array(['Bob', 'Joe', 'Will'],
          dtype='<U4')




In[
55
]
```python
ints = np.array([3,3,3,2,2,1,1,4,4])
```


In[
56
]
```python
np.unique(ints)
```




    array([1, 2, 3, 4])




In[
57
]
```python
values = np.array([6,0,3,2,5,6])
```


In[
58
]
```python
np.in1d(values, [2,3,6])
```




    array([ True, False,  True,  True, False,  True], dtype=bool)



# 4.4 배열의 파일 입,출력


In[
59
]
```python
arr = np.arange(10)
```


In[
60
]
```python
np.save('some_array', arr)
```


In[
61
]
```python
np.load('some_array.npy')
```




    array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])




In[
62
]
```python
np.savez('array_archive.npz', a=arr, b=arr)
```


In[
63
]
```python
arch = np.load('array_archive.npz')
```


In[
64
]
```python
arch['b']
```




    array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])



## 4.5 선형대수


In[
65
]
```python
from numpy.linalg import inv, qr
```


In[
66
]
```python
X = np.random.randn(5,5)
```


In[
67
]
```python
mat = X.T.dot(X)
```


In[
68
]
```python
inv(mat)
```




    array([[ 1.01844224, -0.15794577, -0.2097349 , -0.80404225, -0.04880211],
           [-0.15794577,  0.35552854,  0.10154378,  0.37199682, -0.07227353],
           [-0.2097349 ,  0.10154378,  0.13953878,  0.2609848 , -0.06707296],
           [-0.80404225,  0.37199682,  0.2609848 ,  1.07154054, -0.05102739],
           [-0.04880211, -0.07227353, -0.06707296, -0.05102739,  0.29575561]])




In[
69
]
```python
mat.dot(inv(mat))
```




    array([[  1.00000000e+00,   1.11022302e-16,  -4.16333634e-17,
              0.00000000e+00,   0.00000000e+00],
           [ -3.40005801e-16,   1.00000000e+00,   7.63278329e-17,
              1.49186219e-16,   1.38777878e-17],
           [ -2.49800181e-16,  -8.32667268e-17,   1.00000000e+00,
              4.44089210e-16,  -1.11022302e-16],
           [ -3.70363462e-16,  -4.16333634e-17,   1.48318857e-16,
              1.00000000e+00,   7.11236625e-17],
           [ -1.38777878e-16,  -5.55111512e-17,   5.55111512e-17,
              1.66533454e-16,   1.00000000e+00]])




In[
70
]
```python
q, r = qr(mat)
```


In[
71
]
```python
r
```




    array([[ -4.58745634,   4.45604056,  -5.48124439,  -4.27937643,
             -2.31491372],
           [  0.        ,  -4.42586552,  -3.22511304,   2.27631651,
             -2.40357391],
           [  0.        ,   0.        , -15.16369621,   3.86597121,
             -3.04466875],
           [  0.        ,   0.        ,   0.        ,  -0.71632671,
             -0.52523496],
           [  0.        ,   0.        ,   0.        ,   0.        ,
              3.12837661]])



# 4.6 난수 생성


In[
72
]
```python
samples = np.random.normal(size=(4,4))
```


In[
73
]
```python
samples
```




    array([[ 0.84389786, -0.40101178,  1.19958504, -0.93052097],
           [ 1.23443949, -0.88045482, -0.58540449, -2.02130907],
           [ 0.51106208,  1.07379237,  0.19018405, -0.85829927],
           [-1.08251422, -0.17923159,  1.62270948,  0.3640607 ]])




In[
74
]
```python
from random import normalvariate
```


In[
75
]
```python
N = 1000000
```


In[
76
]
```python
%timeit samples = [normalvariate(0,1) for _ in range(N)]
```

    1.16 s ± 48.7 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)
    


In[
77
]
```python
%timeit np.random.normal(size=N)
```

    36.4 ms ± 792 µs per loop (mean ± std. dev. of 7 runs, 10 loops each)
    

# 4.7 계단 오르내리기 예제


In[
78
]
```python
import random
```


In[
79
]
```python
nsteps = 1000
```


In[
80
]
```python
draws = np.random.randint(0,2,size=nsteps)
```


In[
81
]
```python
steps = np.where(draws > 0, 1, -1)
```


In[
82
]
```python
walk = steps.cumsum()
```


In[
83
]
```python
walk.min()
```




    -60




In[
84
]
```python
walk.max()
```




    5




In[
85
]
```python
(np.abs(walk) >= 10).argmax()
```




    53


---

## Reference

[파이썬 라이브러리를 활용한 데이터 분석](http://www.hanbit.co.kr/store/books/look.php?p_code=B6540908288)